A preliminary version of this paper appears in the proceedings of the 23rd ACM Conference on Computer and Communications Security
(CCS 2016). This is a full version.
Deep Learning with Differential Privacy
October 25, 2016
Martín Abadi∗ Andy Chu∗ Ian Goodfellow†
H. Brendan McMahan∗ Ilya Mironov∗ Kunal Talwar∗
Li Zhang∗
ABSTRACT
Machine learning techniques based on neural networks are
achieving remarkable results in a wide variety of domains.
Often, the training of models requires large, representative
datasets, which may be crowdsourced and contain sensitive
information. The models should not expose private informa-
tion in these datasets. Addressing this goal, we develop new
algorithmic techniques for learning and a reﬁned analysis of
privacy costs within the framework of diﬀerential privacy.
Our implementation and experiments demonstrate that we
can train deep neural networks with non-convex objectives,
under a modest privacy budget, and at a manageable cost in
software complexity, training eﬃciency, and model quality.
1. INTRODUCTION
Recent progress in neural networks has led to impressive
successes in a wide range of applications, including image
classiﬁcation, language representation, move selection for
Go, and many more (e.g., [54, 28, 56, 38, 51]). These ad-
vances are enabled, in part, by the availability of large and
representative datasets for training neural networks. These
datasets are often crowdsourced, and may contain sensitive
information. Their use requires techniques that meet the
demands of the applications while oﬀering principled and
rigorous privacy guarantees.
In this paper, we combine state-of-the-art machine learn-
ing methods with advanced privacy-preserving mechanisms,
training neural networks within a modest (“single-digit”) pri-
vacy budget. We treat models with non-convex objectives,
several layers, and tens of thousands to millions of param-
eters. (In contrast, previous work obtains strong results on
convex models with smaller numbers of parameters, or treats
complex neural networks but with a large privacy loss.) For
this purpose, we develop new algorithmic techniques, a re-
ﬁned analysis of privacy costs within the framework of dif-
ferential privacy, and careful implementation strategies:
∗Google.
†OpenAI. Work done while at Google.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS’16 October 24-28, 2016, Vienna, Austria
c© 2016 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-4139-4/16/10.
DOI: http://dx.doi.org/10.1145/2976749.2978318
1. We demonstrate that, by tracking detailed information
(higher moments) of the privacy loss, we can obtain
much tighter estimates on the overall privacy loss, both
asymptotically and empirically.
2. We improve the computational eﬃciency of diﬀeren-
tially private training by introducing new techniques.
These techniques include eﬃcient algorithms for com-
puting gradients for individual training examples, sub-
dividing tasks into smaller batches to reduce memory
footprint, and applying diﬀerentially private principal
projection at the input layer.
3. We build on the machine learning framework Tensor-
Flow [3] for training models with diﬀerential privacy.
We evaluate our approach on two standard image clas-
siﬁcation tasks, MNIST and CIFAR-10. We chose
these two tasks because they are based on public data-
sets and have a long record of serving as benchmarks
in machine learning. Our experience indicates that
privacy protection for deep neural networks can be
achieved at a modest cost in software complexity, train-
ing eﬃciency, and model quality.
Machine learning systems often comprise elements that
contribute to protecting their training data. In particular,
regularization techniques, which aim to avoid overﬁtting to
the examples used for training, may hide details of those
examples. On the other hand, explaining the internal rep-
resentations in deep neural networks is notoriously diﬃcult,
and their large capacity entails that these representations
may potentially encode ﬁne details of at least some of the
training data. In some cases, a determined adversary may
be able to extract parts of the training data. For example,
Fredrikson et al. demonstrated a model-inversion attack that
recovers images from a facial recognition system [24].
While the model-inversion attack requires only “black-
box” access to a trained model (that is, interaction with the
model via inputs and outputs), we consider adversaries with
additional capabilities, much like Shokri and Shmatikov [50].
Our approach oﬀers protection against a strong adversary
with full knowledge of the training mechanism and access
to the model’s parameters. This protection is attractive,
in particular, for applications of machine learning on mobile
phones, tablets, and other devices. Storing models on-device
enables power-eﬃcient, low-latency inference, and may con-
tribute to privacy since inference does not require commu-
nicating user data to a central server; on the other hand,
we must assume that the model parameters themselves may
be exposed to hostile inspection. Furthermore, when we are
arXiv:1607.00133v2 [stat.ML] 24 Oct 2016
concerned with preserving the privacy of one record in the
training data, we allow for the possibility that the adversary
controls some or even all of the rest of the training data. In
practice, this possibility cannot always be excluded, for ex-
ample when the data is crowdsourced.
The next section reviews background on deep learning and
on diﬀerential privacy. Sections 3 and 4 explain our ap-
proach and implementation. Section 5 describes our exper-
imental results. Section 6 discusses related work, and Sec-
tion 7 concludes. Deferred proofs appear in the Appendix.
2. BACKGROUND
In this section we brieﬂy recall the deﬁnition of diﬀerential
privacy, introduce the Gaussian mechanism and composition
theorems, and overview basic principles of deep learning.
2.1 Differential Privacy
Diﬀerential privacy [19, 16, 20] constitutes a strong stan-
dard for privacy guarantees for algorithms on aggregate data-
bases. It is deﬁned in terms of the application-speciﬁc con-
cept of adjacent databases. In our experiments, for instance,
each training dataset is a set of image-label pairs; we say
that two of these sets are adjacent if they diﬀer in a single
entry, that is, if one image-label pair is present in one set
and absent in the other.
Deﬁnition 1. A randomized mechanism M : D → R with
domain D and range R satisﬁes (ε, δ)-diﬀerential privacy if
for any two adjacent inputs d, d′ ∈ D and for any subset of
outputs S ⊆ R it holds that
Pr[M(d) ∈ S] ≤ eε Pr[M(d′) ∈ S] + δ.
The original deﬁnition of ε-diﬀerential privacy does not in-
clude the additive term δ. We use the variant introduced by
Dwork et al. [17], which allows for the possibility that plain
ε-diﬀerential privacy is broken with probability δ (which is
preferably smaller than 1/|d|).
Diﬀerential privacy has several properties that make it
particularly useful in applications such as ours: composabil-
ity, group privacy, and robustness to auxiliary information.
Composability enables modular design of mechanisms: if all
the components of a mechanism are diﬀerentially private,
then so is their composition. Group privacy implies graceful
degradation of privacy guarantees if datasets contain cor-
related inputs, such as the ones contributed by the same
individual. Robustness to auxiliary information means that
privacy guarantees are not aﬀected by any side information
available to the adversary.
A common paradigm for approximating a deterministic
real-valued function f : D → R with a diﬀerentially private
mechanism is via additive noise calibrated to f ’s sensitivity
Sf , which is deﬁned as the maximum of the absolute distance
|f (d) − f (d′)| where d and d′ are adjacent inputs. (The
restriction to a real-valued function is intended to simplify
this review, but is not essential.) For instance, the Gaussian
noise mechanism is deﬁned by
M(d) ∆
= f (d) + N (0, S2
f · σ2),
where N (0, S2
f · σ2) is the normal (Gaussian) distribution
with mean 0 and standard deviation Sf σ. A single applica-
tion of the Gaussian mechanism to function f of sensitivity
Sf satisﬁes (ε, δ)-diﬀerential privacy if δ ≥ 4
5 exp(−(σε)2/2)
and ε < 1 [20, Theorem 3.22]. Note that this analysis of
the mechanism can be applied post hoc, and, in particular,
that there are inﬁnitely many (ε, δ) pairs that satisfy this
condition.
Diﬀerential privacy for repeated applications of additive-
noise mechanisms follows from the basic composition theo-
rem [17, 18], or from advanced composition theorems and
their reﬁnements [22, 32, 21, 10]. The task of keeping track
of the accumulated privacy loss in the course of execution
of a composite mechanism, and enforcing the applicable pri-
vacy policy, can be performed by the privacy accountant,
introduced by McSherry [40].
The basic blueprint for designing a diﬀerentially private
additive-noise mechanism that implements a given function-
ality consists of the following steps: approximating the func-
tionality by a sequential composition of bounded-sensitivity
functions; choosing parameters of additive noise; and per-
forming privacy analysis of the resulting mechanism. We
follow this approach in Section 3.
2.2 Deep Learning
Deep neural networks, which are remarkably eﬀective for
many machine learning tasks, deﬁne parameterized func-
tions from inputs to outputs as compositions of many layers
of basic building blocks, such as aﬃne transformations and
simple nonlinear functions. Commonly used examples of the
latter are sigmoids and rectiﬁed linear units (ReLUs). By
varying parameters of these blocks, we can “train” such a pa-
rameterized function with the goal of ﬁtting any given ﬁnite
set of input/output examples.
More precisely, we deﬁne a loss function L that represents
the penalty for mismatching the training data. The loss L(θ)
on parameters θ is the average of the loss over the training
examples {x1, . . . , xN }, so L(θ) = 1
N
∑
i L(θ, xi). Training
consists in ﬁnding θ that yields an acceptably small loss,
hopefully the smallest loss (though in practice we seldom
expect to reach an exact global minimum).
For complex networks, the loss function L is usually non-
convex and diﬃcult to minimize. In practice, the minimiza-
tion is often done by the mini-batch stochastic gradient de-
scent (SGD) algorithm. In this algorithm, at each step,
one forms a batch B of random examples and computes
gB = 1/|B| ∑
x∈B ∇θ L(θ, x) as an estimation to the gra-
dient ∇θ L(θ). Then θ is updated following the gradient
direction −gB towards a local minimum.
Several systems have been built to support the deﬁnition
of neural networks, to enable eﬃcient training, and then
to perform eﬃcient inference (execution for ﬁxed parame-
ters) [29, 12, 3]. We base our work on TensorFlow, an open-
source dataﬂow engine released by Google [3]. TensorFlow
allows the programmer to deﬁne large computation graphs
from basic operators, and to distribute their execution across
a heterogeneous distributed system. TensorFlow automates
the creation of the computation graphs for gradients; it also
makes it easy to batch computation.
3. OUR APPROACH
This section describes the main components of our ap-
proach toward diﬀerentially private training of neural net-
works: a diﬀerentially private stochastic gradient descent
(SGD) algorithm, the moments accountant, and hyperpa-
rameter tuning.
3.1 Differentially Private SGD Algorithm
One might attempt to protect the privacy of training data
by working only on the ﬁnal parameters that result from the
training process, treating this process as a black box. Un-
fortunately, in general, one may not have a useful, tight
characterization of the dependence of these parameters on
the training data; adding overly conservative noise to the pa-
rameters, where the noise is selected according to the worst-
case analysis, would destroy the utility of the learned model.
Therefore, we prefer a more sophisticated approach in which
we aim to control the inﬂuence of the training data during
the training process, speciﬁcally in the SGD computation.
This approach has been followed in previous works (e.g., [52,
7]); we make several modiﬁcations and extensions, in par-
ticular in our privacy accounting.
Algorithm 1 outlines our basic method for training a model
with parameters θ by minimizing the empirical loss function
L(θ). At each step of the SGD, we compute the gradient
∇θ L(θ, xi) for a random subset of examples, clip the `2 norm
of each gradient, compute the average, add noise in order to
protect privacy, and take a step in the opposite direction of
this average noisy gradient. At the end, in addition to out-
putting the model, we will also need to compute the privacy
loss of the mechanism based on the information maintained
by the privacy accountant. Next we describe in more detail
each component of this algorithm and our reﬁnements.
Algorithm 1 Diﬀerentially private SGD (Outline)
Input: Examples {x1, . . . , xN }, loss function L(θ) =
1
N
∑
i L(θ, xi). Parameters: learning rate ηt, noise scale
σ, group size L, gradient norm bound C.
Initialize θ0 randomly
for t ∈ [T ] do
Take a random sample Lt with sampling probability
L/N
Compute gradient
For each i ∈ Lt, compute gt(xi) ← ∇θt L(θt, xi)
Clip gradient
¯gt(xi) ← gt(xi)/ max (1, ‖gt(xi)‖2
C
)
Add noise
˜gt ← 1
L
(∑
i ¯gt(xi) + N (0, σ2C2I))
Descent
θt+1 ← θt − ηt ˜gt
Output θT and compute the overall privacy cost (ε, δ)
using a privacy accounting method.
Norm clipping: Proving the diﬀerential privacy guarantee
of Algorithm 1 requires bounding the inﬂuence of each indi-
vidual example on ˜gt. Since there is no a priori bound on
the size of the gradients, we clip each gradient in `2 norm;
i.e., the gradient vector g is replaced by g/ max (1, ‖g‖2
C
),
for a clipping threshold C. This clipping ensures that if
‖g‖2 ≤ C, then g is preserved, whereas if ‖g‖2 > C, it gets
scaled down to be of norm C. We remark that gradient clip-
ping of this form is a popular ingredient of SGD for deep
networks for non-privacy reasons, though in that setting it
usually suﬃces to clip after averaging.
Per-layer and time-dependent parameters: The pseu-
docode for Algorithm 1 groups all the parameters into a
single input θ of the loss function L(·). For multi-layer neu-
ral networks, we consider each layer separately, which allows
setting diﬀerent clipping thresholds C and noise scales σ for
diﬀerent layers. Additionally, the clipping and noise param-
eters may vary with the number of training steps t. In results
presented in Section 5 we use constant settings for C and σ.
Lots: Like the ordinary SGD algorithm, Algorithm 1 esti-
mates the gradient of L by computing the gradient of the
loss on a group of examples and taking the average. This av-
erage provides an unbiased estimator, the variance of which
decreases quickly with the size of the group. We call such a
group a lot, to distinguish it from the computational group-
ing that is commonly called a batch. In order to limit mem-
ory consumption, we may set the batch size much smaller
than the lot size L, which is a parameter of the algorithm.
We perform the computation in batches, then group several
batches into a lot for adding noise. In practice, for eﬃciency,
the construction of batches and lots is done by randomly per-
muting the examples and then partitioning them into groups
of the appropriate sizes. For ease of analysis, however, we as-
sume that each lot is formed by independently picking each
example with probability q = L/N , where N is the size of
the input dataset.
As is common in the literature, we normalize the running
time of a training algorithm by expressing it as the number
of epochs, where each epoch is the (expected) number of
batches required to process N examples. In our notation,
an epoch consists of N/L lots.
Privacy accounting: For diﬀerentially private SGD, an
important issue is computing the overall privacy cost of the
training. The composability of diﬀerential privacy allows
us to implement an “accountant” procedure that computes
the privacy cost at each access to the training data, and
accumulates this cost as the training progresses. Each step
of training typically requires gradients at multiple layers,
and the accountant accumulates the cost that corresponds
to all of them.
Moments accountant: Much research has been devoted
to studying the privacy loss for a particular noise distribu-
tion as well as the composition of privacy losses. For the
Gaussian noise that we use, if we choose σ in Algorithm 1
to be
√
2 log 1.25
δ /ε, then by standard arguments [20] each
step is (ε, δ)-diﬀerentially private with respect to the lot.
Since the lot itself is a random sample from the database,
the privacy ampliﬁcation theorem [33, 8] implies that each
step is (O(qε), qδ)-diﬀerentially private with respect to the
full database where q = L/N is the sampling ratio per lot
and ε ≤ 1. The result in the literature that yields the best
overall bound is the strong composition theorem [22].
However, the strong composition theorem can be loose,
and does not take into account the particular noise distribu-
tion under consideration. In our work, we invent a stronger
accounting method, which we call the moments accountant.
It allows us to prove that Algorithm 1 is (O(qε√T ), δ)-
diﬀerentially private for appropriately chosen settings of the
noise scale and the clipping threshold. Compared to what
one would obtain by the strong composition theorem, our
bound is tighter in two ways: it saves a √log(1/δ) factor in
the ε part and a T q factor in the δ part. Since we expect
δ to be small and T  1/q (i.e., each example is examined
multiple times), the saving provided by our bound is quite
signiﬁcant. This result is one of our main contributions.
Theorem 1. There exist constants c1 and c2 so that given
the sampling probability q = L/N and the number of steps
T , for any ε < c1q2T , Algorithm 1 is (ε, δ)-diﬀerentially
private for any δ > 0 if we choose
σ ≥ c2
q√T log(1/δ)
ε .
If we use the strong composition theorem, we will then
need to choose σ = Ω(q√T log(1/δ) log(T /δ)/ε). Note that
we save a factor of √log(T /δ) in our asymptotic bound. The
moments accountant is beneﬁcial in theory, as this result
indicates, and also in practice, as can be seen from Figure 2
in Section 4. For example, with L = 0.01N , σ = 4, δ =
10−5, and T = 10000, we have ε ≈ 1.26 using the moments
accountant. As a comparison, we would get a much larger
ε ≈ 9.34 using the strong composition theorem.
3.2 The Moments Accountant: Details
The moments accountant keeps track of a bound on the
moments of the privacy loss random variable (deﬁned be-
low in Eq. (1)). It generalizes the standard approach of
tracking (ε, δ) and using the strong composition theorem.
While such an improvement was known previously for com-
posing Gaussian mechanisms, we show that it applies also
for composing Gaussian mechanisms with random sampling
and can provide much tighter estimate of the privacy loss of
Algorithm 1.
Privacy loss is a random variable dependent on the ran-
dom noise added to the algorithm. That a mechanism M
is (ε, δ)-diﬀerentially private is equivalent to a certain tail
bound on M’s privacy loss random variable. While the tail
bound is very useful information on a distribution, compos-
ing directly from it can result in quite loose bounds. We in-
stead compute the log moments of the privacy loss random
variable, which compose linearly. We then use the moments
bound, together with the standard Markov inequality, to ob-
tain the tail bound, that is the privacy loss in the sense of
diﬀerential privacy.
More speciﬁcally, for neighboring databases d, d′ ∈ Dn, a
mechanism M, auxiliary input aux, and an outcome o ∈ R,
deﬁne the privacy loss at o as
c(o; M, aux, d, d′) ∆
= log Pr[M(aux, d) = o]
Pr[M(aux, d′) = o] . (1)
A common design pattern, which we use extensively in the
paper, is to update the state by sequentially applying diﬀer-
entially private mechanisms. This is an instance of adaptive
composition, which we model by letting the auxiliary input
of the kth mechanism Mk be the output of all the previous
mechanisms.
For a given mechanism M, we deﬁne the λth moment
αM(λ; aux, d, d′) as the log of the moment generating func-
tion evaluated at the value λ:
αM(λ; aux, d, d′) ∆
=
log Eo∼M(aux,d)[exp(λc(o; M, aux, d, d′))]. (2)
In order to prove privacy guarantees of a mechanism, it is
useful to bound all possible αM(λ; aux, d, d′). We deﬁne
αM(λ) ∆
= max
aux,d,d′ αM(λ; aux, d, d′) ,
where the maximum is taken over all possible aux and all
the neighboring databases d, d′.
We state the properties of α that we use for the moments
accountant.
Theorem 2. Let αM(λ) deﬁned as above. Then
1. [Composability] Suppose that a mechanism M con-
sists of a sequence of adaptive mechanisms M1, . . . , Mk
where Mi : ∏i−1
j=1 Rj × D → Ri. Then, for any λ
αM(λ) ≤
k∑
i=1
αMi (λ) .
2. [Tail bound] For any ε > 0, the mechanism M is
(ε, δ)-diﬀerentially private for
δ = min
λ exp(αM(λ) − λε) .
In particular, Theorem 2.1 holds when the mechanisms
themselves are chosen based on the (public) output of the
previous mechanisms.
By Theorem 2, it suﬃces to compute, or bound, αMi (λ) at
each step and sum them to bound the moments of the mech-
anism overall. We can then use the tail bound to convert the
moments bound to the (ε, δ)-diﬀerential privacy guarantee.
The main challenge that remains is to bound the value
αMt (λ) for each step. In the case of a Gaussian mechanism
with random sampling, it suﬃces to estimate the following
moments. Let µ0 denote the probability density function
(pdf) of N (0, σ2), and µ1 denote the pdf of N (1, σ2). Let µ
be the mixture of two Gaussians µ = (1 − q)µ0 + qµ1. Then
we need to compute α(λ) = log max(E1, E2) where
E1 = Ez∼µ0 [(µ0(z)/µ(z))λ] , (3)
E2 = Ez∼µ [(µ(z)/µ0(z))λ] . (4)
In the implementation of the moments accountant, we
carry out numerical integration to compute α(λ). In ad-
dition, we can show the asymptotic bound
α(λ) ≤ q2λ(λ + 1)/(1 − q)σ2 + O(q3/σ3) .
Together with Theorem 2, the above bound implies our
main Theorem 1. The details can be found in the Appendix.
3.3 Hyperparameter Tuning
We identify characteristics of models relevant for privacy
and, speciﬁcally, hyperparameters that we can tune in order
to balance privacy, accuracy, and performance. In particu-
lar, through experiments, we observe that model accuracy
is more sensitive to training parameters such as batch size
and noise level than to the structure of a neural network.
If we try several settings for the hyperparameters, we can
trivially add up the privacy costs of all the settings, possibly
via the moments accountant. However, since we care only
about the setting that gives us the most accurate model, we
can do better, such as applying a version of a result from
Gupta et al. [27] restated as Theorem D.1 in the Appendix.
We can use insights from theory to reduce the number of
hyperparameter settings that need to be tried. While diﬀer-
entially private optimization of convex objective functions
is best achieved using batch sizes as small as 1, non-convex
learning, which is inherently less stable, beneﬁts from ag-
gregation into larger batches. At the same time, Theorem 1
suggests that making batches too large increases the pri-
vacy cost, and a reasonable tradeoﬀ is to take the number
of batches per epoch to be of the same order as the desired
number of epochs. The learning rate in non-private train-
ing is commonly adjusted downwards carefully as the model
converges to a local optimum. In contrast, we never need
to decrease the learning rate to a very small value, because
diﬀerentially private training never reaches a regime where
it would be justiﬁed. On the other hand, in our experi-
ments, we do ﬁnd that there is a small beneﬁt to starting
with a relatively large learning rate, then linearly decaying
it to a smaller value in a few epochs, and keeping it constant
afterwards.
4. IMPLEMENTATION
We have implemented the diﬀerentially private SGD al-
gorithms in TensorFlow. The source code is available under
an Apache 2.0 license from github.com/tensorﬂow/models.
For privacy protection, we need to “sanitize” the gradient
before using it to update the parameters. In addition, we
need to keep track of the “privacy spending” based on how
the sanitization is done. Hence our implementation mainly
consists of two components: sanitizer, which preprocesses
the gradient to protect privacy, and privacy_accountant,
which keeps track of the privacy spending over the course of
training.
Figure 1 contains the TensorFlow code snippet (in Python)
of DPSGD_Optimizer, which minimizes a loss function us-
ing a diﬀerentially private SGD, and DPTrain, which itera-
tively invokes DPSGD_Optimizer using a privacy accountant
to bound the total privacy loss.
In many cases, the neural network model may beneﬁt from
the processing of the input by projecting it on the principal
directions (PCA) or by feeding it through a convolutional
layer. We implement diﬀerentially private PCA and apply
pre-trained convolutional layers (learned on public data).
Sanitizer. In order to achieve privacy protection, the sani-
tizer needs to perform two operations: (1) limit the sensitiv-
ity of each individual example by clipping the norm of the
gradient for each example; and (2) add noise to the gradient
of a batch before updating the network parameters.
In TensorFlow, the gradient computation is batched for
performance reasons, yielding gB = 1/|B| ∑
x∈B ∇θ L(θ, x)
for a batch B of training examples. To limit the sensitivity
of updates, we need to access each individual ∇θ L(θ, x). To
this end, we implemented per_example_gradient operator
in TensorFlow, as described by Goodfellow [25]. This opera-
tor can compute a batch of individual ∇θ L(θ, x). With this
implementation there is only a modest slowdown in train-
ing, even for larger batch size. Our current implementation
supports batched computation for the loss function L, where
each xi is singly connected to L, allowing us to handle most
hidden layers but not, for example, convolutional layers.
Once we have the access to the per-example gradient, it
is easy to use TensorFlow operators to clip its norm and to
add noise.
Privacy accountant. The main component in our imple-
mentation is PrivacyAccountant which keeps track of pri-
vacy spending over the course of training. As discussed in
Section 3, we implemented the moments accountant that ad-
ditively accumulates the log of the moments of the privacy
loss at each step. Dependent on the noise distribution, one
can compute α(λ) by either applying an asymptotic bound,
evaluating a closed-form expression, or applying numerical
class DPSGD_Optimizer():
def __init__(self, accountant, sanitizer):
self._accountant = accountant
self._sanitizer = sanitizer
def Minimize(self, loss, params,
batch_size, noise_options):
# Accumulate privacy spending before computing
# and using the gradients.
priv_accum_op =
self._accountant.AccumulatePrivacySpending(
batch_size, noise_options)
with tf.control_dependencies(priv_accum_op):
# Compute per example gradients
px_grads = per_example_gradients(loss, params)
# Sanitize gradients
sanitized_grads = self._sanitizer.Sanitize(
px_grads, noise_options)
# Take a gradient descent step
return apply_gradients(params, sanitized_grads)
def DPTrain(loss, params, batch_size, noise_options):
accountant = PrivacyAccountant()
sanitizer = Sanitizer()
dp_opt = DPSGD_Optimizer(accountant, sanitizer)
sgd_op = dp_opt.Minimize(
loss, params, batch_size, noise_options)
eps, delta = (0, 0)
# Carry out the training as long as the privacy
# is within the pre-set limit.
while within_limit(eps, delta):
sgd_op.run()
eps, delta = accountant.GetSpentPrivacy()
Figure 1: Code snippet of DPSGD_Optimizer and DP-
Train.
integration. The ﬁrst option would recover the generic ad-
vanced composition theorem, and the latter two give a more
accurate accounting of the privacy loss.
For the Gaussian mechanism we use, α(λ) is deﬁned ac-
cording to Eqs. (3) and (4). In our implementation, we
carry out numerical integration to compute both E1 and E2
in those equations. Also we compute α(λ) for a range of
λ’s so we can compute the best possible (ε, δ) values using
Theorem 2.2. We ﬁnd that for the parameters of interest to
us, it suﬃces to compute α(λ) for λ ≤ 32.
At any point during training, one can query the privacy
loss in the more interpretable notion of (ε, δ) privacy using
Theorem 2.2. Rogers et al. [47] point out risks associated
with adaptive choice of privacy parameters. We avoid their
attacks and negative results by ﬁxing the number of iter-
ations and privacy parameters ahead of time. More gen-
eral implementations of a privacy accountant must correctly
distinguish between two modes of operation—as a privacy
odometer or a privacy ﬁlter (see [47] for more details).
Diﬀerentially private PCA. Principal component analy-
sis (PCA) is a useful method for capturing the main features
of the input data. We implement the diﬀerentially private
PCA algorithm as described in [23]. More speciﬁcally, we
take a random sample of the training examples, treat them
as vectors, and normalize each vector to unit `2 norm to
form the matrix A, where each vector is a row in the ma-
trix. We then add Gaussian noise to the covariance matrix
AT A and compute the principal directions of the noisy co-
variance matrix. Then for each input example we apply the
projection to these principal directions before feeding it into
the neural network.
We incur a privacy cost due to running a PCA. However,
we ﬁnd it useful for both improving the model quality and for
reducing the training time, as suggested by our experiments
on the MNIST data. See Section 4 for details.
Convolutional layers. Convolutional layers are useful for
deep neural networks. However, an eﬃcient per-example
gradient computation for convolutional layers remains a chal-
lenge within the TensorFlow framework, which motivates
creating a separate workﬂow. For example, some recent
work argues that even random convolutions often suﬃce [46,
13, 49, 55, 14].
Alternatively, we explore the idea of learning convolu-
tional layers on public data, following Jarrett et al. [30].
Such convolutional layers can be based on GoogLeNet or
AlexNet features [54, 35] for image models or on pretrained
word2vec or GloVe embeddings in language models [41, 44].
5. EXPERIMENTAL RESULTS
This section reports on our evaluation of the moments ac-
countant, and results on two popular image datasets: MNIST
and CIFAR-10.
5.1 Applying the Moments Accountant
As shown by Theorem 1, the moments accountant pro-
vides a tighter bound on the privacy loss compared to the
generic strong composition theorem. Here we compare them
using some concrete values. The overall privacy loss (ε, δ)
can be computed from the noise level σ, the sampling ra-
tio of each lot q = L/N (so each epoch consists of 1/q
batches), and the number of epochs E (so the number of
steps is T = E/q). We ﬁx the target δ = 10−5, the value
used for our MNIST and CIFAR experiments.
In our experiment, we set q = 0.01, σ = 4, and δ = 10−5,
and compute the value of ε as a function of the training
epoch E. Figure 2 shows two curves corresponding to, re-
spectively, using the strong composition theorem and the
moments accountant. We can see that we get a much tighter
estimation of the privacy loss by using the moments accoun-
tant. For examples, when E = 100, the values are 9.34
and 1.26 respectively, and for E = 400, the values are 24.22
and 2.55 respectively. That is, using the moments bound,
we achieve (2.55, 10−5)-diﬀerential privacy, whereas previ-
ous techniques only obtain the signiﬁcantly worse guarantee
of (24.22, 10−5).
5.2 MNIST
We conduct experiments on the standard MNIST dataset
for handwritten digit recognition consisting of 60,000 train-
ing examples and 10,000 testing examples [36]. Each exam-
ple is a 28 × 28 size gray-level image. We use a simple feed-
forward neural network with ReLU units and softmax of 10
classes (corresponding to the 10 digits) with cross-entropy
loss and an optional PCA input layer.
Baseline model.
Our baseline model uses a 60-dimensional PCA projection
layer and a single hidden layer with 1,000 hidden units. Us-
ing the lot size of 600, we can reach accuracy of 98.30% in
about 100 epochs. This result is consistent with what can
be achieved with a vanilla neural network [36].
Figure 2: The ε value as a function of epoch E for
q = 0.01, σ = 4, δ = 10−5, using the strong composition
theorem and the moments accountant respectively.
Differentially private model.
For the diﬀerentially private version, we experiment with
the same architecture with a 60-dimensional PCA projection
layer, a single 1,000-unit ReLU hidden layer, and a lot size of
600. To limit sensitivity, we clip the gradient norm of each
layer at 4. We report results for three choices of the noise
scale, which we call small (σ = 2, σp = 4), medium (σ =
4, σp = 7), and large (σ = 8, σp = 16). Here σ represents
the noise level for training the neural network, and σp the
noise level for PCA projection. The learning rate is set at 0.1
initially and linearly decreased to 0.052 over 10 epochs and
then ﬁxed to 0.052 thereafter. We have also experimented
with multi-hidden-layer networks. For MNIST, we found
that one hidden layer combined with PCA works better than
a two-layer network.
Figure 3 shows the results for diﬀerent noise levels. In
each plot, we show the evolution of the training and testing
accuracy as a function of the number of epochs as well as
the corresponding δ value, keeping ε ﬁxed. We achieve 90%,
95%, and 97% test set accuracy for (0.5, 10−5), (2, 10−5),
and (8, 10−5)-diﬀerential privacy respectively.
One attractive consequence of applying diﬀerentially pri-
vate SGD is the small diﬀerence between the model’s ac-
curacy on the training and the test sets, which is consis-
tent with the theoretical argument that diﬀerentially private
training generalizes well [6]. In contrast, the gap between
training and testing accuracy in non-private training, i.e.,
evidence of overﬁtting, increases with the number of epochs.
By using the moments accountant, we can obtain a δ value
for any given ε. We record the accuracy for diﬀerent (ε, δ)
pairs in Figure 4. In the ﬁgure, each curve corresponds to the
best accuracy achieved for a ﬁxed δ, as it varies between 10−5
and 10−2. For example, we can achieve 90% accuracy for
ε = 0.25 and δ = 0.01. As can be observed from the ﬁgure,
for a ﬁxed δ, varying the value of ε can have large impact
on accuracy, but for any ﬁxed ε, there is less diﬀerence with
diﬀerent δ values.
Effect of the parameters.
Classiﬁcation accuracy is determined by multiple factors
(1) Large noise (2) Medium noise (3) Small noise
Figure 3: Results on the accuracy for diﬀerent noise levels on the MNIST dataset. In all the experiments, the
network uses 60 dimension PCA projection, 1,000 hidden units, and is trained using lot size 600 and clipping
threshold 4. The noise levels (σ, σp) for training the neural network and for PCA projection are set at (8, 16),
(4, 7), and (2, 4), respectively, for the three experiments.
Figure 4: Accuracy of various (ε, δ) privacy values
on the MNIST dataset. Each curve corresponds to
a diﬀerent δ value.
that must be carefully tuned for optimal performance. These
factors include the topology of the network, the number of
PCA dimensions and the number of hidden units, as well as
parameters of the training procedure such as the lot size and
the learning rate. Some parameters are speciﬁc to privacy,
such as the gradient norm clipping bound and the noise level.
To demonstrate the eﬀects of these parameters, we manip-
ulate them individually, keeping the rest constant. We set
the reference values as follows: 60 PCA dimensions, 1,000
hidden units, 600 lot size, gradient norm bound of 4, ini-
tial learning rate of 0.1 decreasing to a ﬁnal learning rate
of 0.052 in 10 epochs, and noise σ equal to 4 and 7 respec-
tively for training the neural network parameters and for the
PCA projection. For each combination of values, we train
until the point at which (2, 10−5)-diﬀerential privacy would
be violated (so, for example, a larger σ allows more epochs
of training). The results are presented in Figure 5.
PCA projection. In our experiments, the accuracy is
fairly stable as a function of the PCA dimension, with the
best results achieved for 60. (Not doing PCA reduces ac-
curacy by about 2%.) Although in principle the PCA pro-
jection layer can be replaced by an additional hidden layer,
we achieve better accuracy by training the PCA layer sep-
arately. By reducing the input size from 784 to 60, PCA
leads to an almost 10× reduction in training time. The re-
sult is fairly stable over a large range of the noise levels for
the PCA projection and consistently better than the accu-
racy using random projection, which is at about 92.5% and
shown as a horizontal line in the plot.
Number of hidden units. Including more hidden units
makes it easier to ﬁt the training set. For non-private train-
ing, it is often preferable to use more units, as long as we
employ techniques to avoid overﬁtting. However, for diﬀer-
entially private training, it is not a priori clear if more hidden
units improve accuracy, as more hidden units increase the
sensitivity of the gradient, which leads to more noise added
at each update.
Somewhat counterintuitively, increasing the number of
hidden units does not decrease accuracy of the trained model.
One possible explanation that calls for further analysis is
that larger networks are more tolerant to noise. This prop-
erty is quite encouraging as it is common in practice to use
very large networks.
Lot size. According to Theorem 1, we can run N/L epochs
while staying within a constant privacy budget. Choosing
the lot size must balance two conﬂicting objectives. On the
one hand, smaller lots allow running more epochs, i.e., passes
over data, improving accuracy. On the other hand, for a
larger lot, the added noise has a smaller relative eﬀect.
Our experiments show that the lot size has a relatively
large impact on accuracy. Empirically, the best lot size is
roughly √N where N is the number of training examples.
Learning rate. Accuracy is stable for a learning rate in
the range of [0.01, 0.07] and peaks at 0.05, as shown in Fig-
ure 5(4). However, accuracy decreases signiﬁcantly if the
learning rate is too large. Some additional experiments sug-
gest that, even for large learning rates, we can reach similar
levels of accuracy by reducing the noise level and, accord-
ingly, by training less in order to avoid exhausting the pri-
vacy budget.
Clipping bound. Limiting the gradient norm has two op-
posing eﬀects: clipping destroys the unbiasedness of the gra-
dient estimate, and if the clipping parameter is too small,
the average clipped gradient may point in a very diﬀerent
(1) variable projection dimensions (2) variable hidden units (3) variable lot size
(4) variable learning rate (5) variable gradient clipping norm (6) variable noise level
Figure 5: MNIST accuracy when one parameter varies, and the others are ﬁxed at reference values.
direction from the true gradient. On the other hand, in-
creasing the norm bound C forces us to add more noise to
the gradients (and hence the parameters), since we add noise
based on σC. In practice, a good way to choose a value for
C is by taking the median of the norms of the unclipped
gradients over the course of training.
Noise level. By adding more noise, the per-step privacy
loss is proportionally smaller, so we can run more epochs
within a given cumulative privacy budget. In Figure 5(5),
the x-axis is the noise level σ. The choice of this value has
a large impact on accuracy.
From the experiments, we observe the following.
1. The PCA projection improves both model accuracy
and training performance. Accuracy is quite stable
over a large range of choices for the projection dimen-
sions and the noise level used in the PCA stage.
2. The accuracy is fairly stable over the network size.
When we can only run smaller number of epochs, it is
more beneﬁcial to use a larger network.
3. The training parameters, especially the lot size and
the noise scale σ, have a large impact on the model
accuracy. They both determine the “noise-to-signal”
ratio of the sanitized gradients as well as the number
of epochs we are able to go through the data before
reaching the privacy limit.
Our framework allows for adaptive control of the training
parameters, such as the lot size, the gradient norm bound
C, and noise level σ. Our initial experiments with decreas-
ing noise as training progresses did not show a signiﬁcant
improvement, but it is interesting to consider more sophis-
ticated schemes for adaptively choosing these parameters.
5.3 CIFAR
We also conduct experiments on the CIFAR-10 dataset,
which consists of color images classiﬁed into 10 classes such
as ships, cats, and dogs, and partitioned into 50,000 training
examples and 10,000 test examples [1]. Each example is a
32 × 32 image with three channels (RGB). For this learning
task, nearly all successful networks use convolutional layers.
The CIFAR-100 dataset has similar parameters, except that
images are classiﬁed into 100 classes; the examples and the
image classes are diﬀerent from those of CIFAR-10.
We use the network architecture from the TensorFlow con-
volutional neural networks tutorial [2]. Each 32 × 32 image
is ﬁrst cropped to a 24 × 24 one by taking the center patch.
The network architecture consists of two convolutional lay-
ers followed by two fully connected layers. The convolutional
layers use 5 × 5 convolutions with stride 1, followed by a
ReLU and 2 × 2 max pools, with 64 channels each. Thus
the ﬁrst convolution outputs a 12 × 12 × 64 tensor for each
image, and the second outputs a 6×6×64 tensor. The latter
is ﬂattened to a vector that gets fed into a fully connected
layer with 384 units, and another one of the same size.
This architecture, non-privately, can get to about 86% ac-
curacy in 500 epochs. Its simplicity makes it an appealing
choice for our work. We should note however that by us-
ing deeper networks with diﬀerent non-linearities and other
advanced techniques, one can obtain signiﬁcantly better ac-
curacy, with the state-of-the-art being about 96.5% [26].
As is standard for such image datasets, we use data aug-
mentation during training. For each training image, we gen-
erate a new distorted image by randomly picking a 24 × 24
patch from the image, randomly ﬂipping the image along
the left-right direction, and randomly distorting the bright-
ness and the contrast of the image. In each epoch, these
(1) ε = 2 (2) ε = 4 (3) ε = 8
Figure 6: Results on accuracy for diﬀerent noise levels on CIFAR-10. With δ set to 10−5, we achieve accuracy
67%, 70%, and 73%, with ε being 2, 4, and 8, respectively. The ﬁrst graph uses a lot size of 2,000, (2) and (3)
use a lot size of 4,000. In all cases, σ is set to 6, and clipping is set to 3.
distortions are done independently. We refer the reader to
the TensorFlow tutorial [2] for additional details.
As the convolutional layers have shared parameters, com-
puting per-example gradients has a larger computational
overhead. Previous work has shown that convolutional lay-
ers are often transferable: parameters learned from one data-
set can be used on another one without retraining [30]. We
treat the CIFAR-100 dataset as a public dataset and use it
to train a network with the same architecture. We use the
convolutions learned from training this dataset. Retrain-
ing only the fully connected layers with this architecture for
about 250 epochs with a batch size of 120 gives us approxi-
mately 80% accuracy, which is our non-private baseline.
Differentially private version.
For the diﬀerentially private version, we use the same ar-
chitecture. As discussed above, we use pre-trained convolu-
tional layers. The fully connected layers are initialized from
the pre-trained network as well. We train the softmax layer,
and either the top or both fully connected layers. Based on
looking at gradient norms, the softmax layer gradients are
roughly twice as large as the other two layers, and we keep
this ratio when we try clipping at a few diﬀerent values be-
tween 3 and 10. The lot size is an additional knob that we
tune: we tried 600, 2,000, and 4,000. With these settings,
the per-epoch training time increases from approximately 40
seconds to 180 seconds.
In Figure 6, we show the evolution of the accuracy and
the privacy cost, as a function of the number of epochs, for
a few diﬀerent parameter settings.
The various parameters inﬂuence the accuracy one gets, in
ways not too diﬀerent from that in the MNIST experiments.
A lot size of 600 leads to poor results on this dataset and
we need to increase it to 2,000 or more for results reported
in Figure 6.
Compared to the MNIST dataset, where the diﬀerence in
accuracy between a non-private baseline and a private model
is about 1.3%, the corresponding drop in accuracy in our
CIFAR-10 experiment is much larger (about 7%). We leave
closing this gap as an interesting test for future research in
diﬀerentially private machine learning.
6. RELATED WORK
The problem of privacy-preserving data mining, or ma-
chine learning, has been a focus of active work in several
research communities since the late 90s [5, 37]. The exist-
ing literature can be broadly classiﬁed along several axes:
the class of models, the learning algorithm, and the privacy
guarantees.
Privacy guarantees. Early works on privacy-preserving
learning were done in the framework of secure function eval-
uation (SFE) and secure multi-party computations (MPC),
where the input is split between two or more parties, and
the focus is on minimizing information leaked during the
joint computation of some agreed-to functionality. In con-
trast, we assume that data is held centrally, and we are
concerned with leakage from the functionality’s output (i.e.,
the model).
Another approach, k-anonymity and closely related no-
tions [53], seeks to oﬀer a degree of protection to underlying
data by generalizing and suppressing certain identifying at-
tributes. The approach has strong theoretical and empirical
limitations [4, 9] that make it all but inapplicable to de-
anonymization of high-dimensional, diverse input datasets.
Rather than pursue input sanitization, we keep the under-
lying raw records intact and perturb derived data instead.
The theory of diﬀerential privacy, which provides the an-
alytical framework for our work, has been applied to a large
collection of machine learning tasks that diﬀered from ours
either in the training mechanism or in the target model.
The moments accountant is closely related to the notion of
R´enyi diﬀerential privacy [42], which proposes (scaled) α(λ)
as a means of quantifying privacy guarantees. In a concur-
rent and independent work Bun and Steinke [10] introduce
a relaxation of diﬀerential privacy (generalizing the work
of Dwork and Rothblum [20]) deﬁned via a linear upper
bound on α(λ). Taken together, these works demonstrate
that the moments accountant is a useful technique for theo-
retical and empirical analyses of complex privacy-preserving
algorithms.
Learning algorithm. A common target for learning with
privacy is a class of convex optimization problems amenable
to a wide variety of techniques [18, 11, 34]. In concurrent
work, Wu et al. achieve 83% accuracy on MNIST via con-
vex empirical risk minimization [57]. Training multi-layer
neural networks is non-convex, and typically solved by an
application of SGD, whose theoretical guarantees are poorly
understood.
For the CIFAR neural network we incorporate diﬀeren-
tially private training of the PCA projection matrix [23],
which is used to reduce dimensionality of inputs.
Model class. The ﬁrst end-to-end diﬀerentially private sys-
tem was evaluated on the Netﬂix Prize dataset [39], a version
of a collaborative ﬁltering problem. Although the problem
shared many similarities with ours—high-dimensional in-
puts, non-convex objective function—the approach taken by
McSherry and Mironov diﬀered signiﬁcantly. They identiﬁed
the core of the learning task, eﬀectively suﬃcient statistics,
that can be computed in a diﬀerentially private manner via
a Gaussian mechanism. In our approach no such suﬃcient
statistics exist.
In a recent work Shokri and Shmatikov [50] designed and
evaluated a system for distributed training of a deep neural
network. Participants, who hold their data closely, commu-
nicate sanitized updates to a central authority. The sani-
tization relies on an additive-noise mechanism, based on a
sensitivity estimate, which could be improved to a hard sen-
sitivity guarantee. They compute privacy loss per param-
eter (not for an entire model). By our preferred measure,
the total privacy loss per participant on the MNIST dataset
exceeds several thousand.
A diﬀerent, recent approach towards diﬀerentially private
deep learning is explored by Phan et al. [45]. This work
focuses on learning autoencoders. Privacy is based on per-
turbing the objective functions of these autoencoders.
7. CONCLUSIONS
We demonstrate the training of deep neural networks with
diﬀerential privacy, incurring a modest total privacy loss,
computed over entire models with many parameters. In
our experiments for MNIST, we achieve 97% training accu-
racy and for CIFAR-10 we achieve 73% accuracy, both with
(8, 10−5)-diﬀerential privacy. Our algorithms are based on a
diﬀerentially private version of stochastic gradient descent;
they run on the TensorFlow software library for machine
learning. Since our approach applies directly to gradient
computations, it can be adapted to many other classical
and more recent ﬁrst-order optimization methods, such as
NAG [43], Momentum [48], AdaGrad [15], or SVRG [31].
A new tool, which may be of independent interest, is a
mechanism for tracking privacy loss, the moments accoun-
tant. It permits tight automated analysis of the privacy loss
of complex composite mechanisms that are currently beyond
the reach of advanced composition theorems.
A number of avenues for further work are attractive. In
particular, we would like to consider other classes of deep
networks. Our experience with MNIST and CIFAR-10 should
be helpful, but we see many opportunities for new research,
for example in applying our techniques to LSTMs used for
language modeling tasks. In addition, we would like to ob-
tain additional improvements in accuracy. Many training
datasets are much larger than those of MNIST and CIFAR-
10; accuracy should beneﬁt from their size.